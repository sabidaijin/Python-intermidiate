# 以下は、3層の一般的な MLP で、各層のノード数を 3, 5, 4として、ウェイトとバイアスを以下のように設定した場合の順伝播の計算例です。必要な方は、計算結果の確認の参考にしてください。

# 𝑾1=⎛⎝⎜⎜−1.011.11−1.211.03−1.131.23−1.051.15−1.251.07−1.171.27−1.091.19−1.29⎞⎠⎟⎟

# 𝑩1=(−1.31−1.331.35−1.371.39)

# 𝑾2=⎛⎝⎜⎜⎜⎜⎜−2.02−2.1−2.18−2.26−2.342.042.122.22.282.36−2.06−2.14−2.22−2.3−2.382.082.162.242.322.4⎞⎠⎟⎟⎟⎟⎟

# 𝑩2=(−2.422.44−2.462.48)


# 入力: (2, 1, 3)

# 出力
# 活性化関数無し:
# (4.9118, -4.9588, 5.0058, -5.0528)

# シグモイド関数:
# (0.00105447, 0.999008, 0.000934061, 0.999121)

# ReLU:
# (0, 17.1896, 0, 17.4976)

# 順伝播の計算を実装する（バックプロパテーションはスコープアウト)
# 

def sigm():
    1/1+e**-x

def relu():
    if x>0:
        x
    else:
        0
def sim():


W1=[
[-1.01,  1.03, -1.05,  1.07, -1.09]
[1.11, -1.13,  1.15, -1.17,  1.19]
[-1.21,  1.23, -1.25,  1.27, -1.29]]

B1=[-1.31,-1.33,1.35,-1.37,1.39]

W2=[
    [2.02, 2.04, -2.06, 2.08]
    [-2.1 , 2.12, -2.14, 2.16]
    [-2.18, 2.2 , -2.22, 2.24]
    [-2.26, 2.28, -2.3 , 2.32]
    [-2.34, 2.36, -2.38, 2.4 ]]



B2=[-2.42,2.44,-2.46,2.48]
n=int(input())

if flag==0:
    sigm()
else if flag==1:
    relu()
else:
    sim()
